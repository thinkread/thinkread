[{"title":"设计模式之行为模式使用场景","date":"2017-03-30T00:59:42.000Z","path":"2017/03/30/设计模式之行为模式使用场景/","text":"行为型模式行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 策略模式–运行时使用不同的策略1、 多个类只区别在表现行为不同，可以使用Strategy模式，在运行时动态选择具体要执行的行为。 1、 多个类只区别在表现行为不同，可以使用Strategy模式，在运行时动态选择具体要执行的行为。2、 需要在不同情况下使用不同的策略(算法)，或者策略还可能在未来用其它方式来实现。 1、 多个类只区别在表现行为不同，可以使用Strategy模式，在运行时动态选择具体要执行的行为。2、 需要在不同情况下使用不同的策略(算法)，或者策略还可能在未来用其它方式来实现。3、 对客户隐藏具体策略(算法)的实现细节，彼此完全独立。 定义一系列的算法，把他们一个个封装起来，并使他们可以互相替换，本模式使得算法可以独立于使用它们的客户。 模板方法模式–避免代码重复定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，TemplateMethod使得子类可以不改变一个算法的结构即可以重定义该算法的某些特定步骤。 应用场景：一个操作的步骤稳定，而具体细节的改变延迟的子类 在某些类的算法中，用了相同的方法，造成代码的重复。 控制子类扩展，子类必须遵守算法规则。 观察者模式 –观察通知,应用场景 1 当一个对象的改变需要给变其它对象时，而且它不知道具体有多少个对象有待改变时。 2 一个抽象某型有两个方面，当其中一个方面依赖于另一个方面，这时用观察者模式可以将这两者封装在独立的对象中使它们各自独立地改变和复用。 迭代Iterator模式–提供迭代遍历提供一个方法顺序访问一个聚合对象的各个元素，而又不需要暴露该对象的内部表示 迭代器模式是与集合共生共死的，一般来说，我们只要实现一个集合，就需要同时提供这个集合的迭代器，就像java中的Collection，List、Set、Map等，这些集合都有自己的迭代器。假如我们要实现一个这样的新的容器，当然也需要引入迭代器模式，给我们的容器实现一个迭代器。 但是，由于容器与迭代器的关系太密切了，所以大多数语言在实现容器的时候都给提供了迭代器，并且这些语言提供的容器和迭代器在绝大多数情况下就可以满足我们的需要，所以现在需要我们自己去实践迭代器模式的场景还是比较少见的，我们只需要使用语言中已有的容器和迭代器就可以了。 责任链模式使多个对象都有机会处理请求，从而避免请求的送发者和接收者之间的耦合关系 责任链模式的优点是调用者不需知道具体谁来处理请求，也不知道链的具体结构，降低了节点域节点的耦合度；可在运行时动态修改链中的对象职责，增强了给对象指派职责的灵活性；缺点是没有明确的接收者，可能传到链的最后，也没得到正确的处理。 命令模式 –将命令者与执行者完全解耦将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化，对请求排队和记录请求日志，以及支持可撤销的操作。 应用场景：将命令者与执行者完全解耦。 任何模式的出现，都是为了解决一些特定的场景的耦合问题，以达到对修改封闭，对扩展开放的效果。命令模式也不例外： 命令模式是为了解决命令的请求者和命令的实现者之间的耦合关系。 解决了这种耦合的好处我认为主要有两点： 1.更方便的对命令进行扩展（注意：这不是主要的优势，后面会提到） 2.对多个命令的统一控制（这种控制包括但不限于：队列、撤销/恢复、记录日志等等） 备忘录模式–提供内部对象状态备份在不破坏对象的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。 状态模式–状态间切换允许对象在其内部状态改变时改变他的行为。对象看起来似乎改变了他的类。 应用场景：一个对象的内部状态改变时，他的行为剧烈的变化。 主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同的一系列类当中，可以把复杂的逻辑判断简单化。 当一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为时，就可以考虑使用状态模式来。 一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态。 访问者模式表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定义作用于这个元素的新操作。 中介者模式用一个中介对象封装一些列的对象交互。 解释器模式给定一个语言，定义他的文法的一个表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子","tags":[]},{"title":"设计模式之结构模式使用场景","date":"2017-03-30T00:59:42.000Z","path":"2017/03/30/设计模式之结构模式使用场景 /","text":"结构型模式结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 作用 主要针对软件的结构 适配器模式–给不同的系统做转换主要分为三类：类适配器模式、对象的适配器模式、接口的适配器模式。 作用 1 系统需要使用现有的类，而这些类的接口不符合系统的需要。 2 想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。3 需要一个统一的输出接口，而输入端的类型不可预知。 外观模式 –新老系统的交互 1需要将设计进行分层时考虑Facade模式。 2在开发阶段，子系统往往因为重构变得越来越复杂，增加外观模式可以提供一个简单的接口，减少它们之间的依赖。 3在维护一个遗留的大型系统时，可以这个系统已经非常难以维护和扩展，可以为新系统开发一个Facade类，来提供设计粗糙或高度复杂的遗留代码的比较清晰简单的接口，让新系统与Facade对象交互，Facade与遗留代码交互所有复杂的工作。 桥接模式–将抽象部分与它的实现部分相分离，使他们可以独立的变化1．如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的联系。 1．如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的联系。2．设计要求实现化角色的任何改变不应当影响客户端，或者说实现化角色的改变对客户端是完全透明的。 1．如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的联系。2．设计要求实现化角色的任何改变不应当影响客户端，或者说实现化角色的改变对客户端是完全透明的。3．一个构件有多于一个的抽象化角色和实现化角色，系统需要它们之间进行动态耦合。 1．如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的联系。2．设计要求实现化角色的任何改变不应当影响客户端，或者说实现化角色的改变对客户端是完全透明的。3．一个构件有多于一个的抽象化角色和实现化角色，系统需要它们之间进行动态耦合。4．虽然在系统中使用继承是没有问题的，但是由于抽象化角色和具体化角色需要独立变化，设计要求需要独立管理这两者。 装饰器模式 –给对象添加扩展功能使用场景 \\1. 需要扩展一个类的功能，或给一个类添加附加职责。 \\2. 需要动态的给一个对象添加功能，这些功能可以再动态的撤销。 \\3. 需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变的不现实。 \\4. 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。 代理模式–代替客户进行内部交互使用场景 一个对象，比如一幅很大的图像，需要载入的时间很长。 一个需要很长时间才可以完成的计算结果，并且需要在它计算过程中显示中间结果 一个存在于远程计算机上的对象，需要通过网络载入这个远程对象则需要很长时间，特别是在网络传输高峰期。 一个对象只有有限的访问权限，代理模式(Proxy)可以验证用户的权限 组合模式–将对象组合成树形结构以表示部分整体的关系,Composite使得用户对单个对象和组合对象的使用具有一致性当发现需求中是体现部分与整体层次结构时，以及你希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时，就应该考虑组合模式了 享元模式–减少内存消耗它使用共享物件，用来尽可能减少内存使用量以及分享资讯给尽可能多的相似物件；它适合用于只是因重复而导致使用无法令人接受的大量内存的大量物件。通常物件中的部分状态是可以分享。常见做法是把它们放在外部数据结构，当需要使用时再将它们传递给享元","tags":[]},{"title":"设计模式之创建模式使用场景","date":"2017-03-30T00:59:42.000Z","path":"2017/03/30/设计模式之创建模式使用场景/","text":"工厂模式–创建产品化创建对象作用：两个类A和B之间的关系应该仅仅是A创建B或是A使用B，而不能两种关系都有。将对象的创建和使用分离，也使得系统更加符合“单一职责原则”，有利于对功能的复用和系统的维护。 工厂方法模式 每个子工厂生产出来的都是独特的产品 抽象工厂模式 针对的多个产品等级结构。在编程中，通常一个产品结构，表现为一个接口或者抽象类，也就是说，工厂方法模式提供的所有产品都是衍生自同一个接口或抽象类，而抽象工厂模式所提供的产品则是衍生自不同的接口或抽象类。 单例模式–创建单一对象单例模式 作用 1、控制资源的使用，通过线程同步来控制资源的并发访问； 2、控制实例产生的数量，达到节约资源的目的。 3、作为通信媒介使用，也就是数据共享，它可以在不建立直接关联的条件下，让多个不相关的两个线程或者进程之间实现通信 创建内部结构复杂对象建造者模式 作用 1.创建一些复杂的对象时，这些对象的内部组成构件间的建造顺序是稳定的，但是对象的内部组成构件面临着复杂的变化。 2.要创建的复杂对象的算法，独立于该对象的组成部分，也独立于组成部分的装配方法时。 复制对象,进行创建原型模式 就是通过复制现在已经有了的实例来创建新的实例，达到节省创建时间.","tags":[]},{"title":"程序员提高效率工具","date":"2017-03-30T00:21:23.000Z","path":"2017/03/30/程序员提高效率工具/","text":"1、Notepad++ Notepad++ 程序员必备的文本编辑器，软件小巧高效，支持27种编程语言，通吃C, C++, Java, C#, XML, HTML, PHP, JS 等，推荐各位下载使用。Notepad++ 可完美地取代微软的记事本。相信这是每个程序员必备的工具，神器不解释！ 2、XML Marker XML Marker是国外的一款非常实用的xml查看编辑工具。软件功能强大，纯文本调试输出和日志文件，你可以有效增加修改你的程序才能产生XML格式他们的作用。 3、Everything Everything是速度最快的文件搜索软件。其速度之快令人震惊，百G硬盘几十万个文件，可以在几秒钟之内完成索引；文件名搜索瞬间呈现结果。它小巧免费，支持中文，支持正则表达式，可以通过HTTP或FTP分享搜索结果。 4、MarkMan 既有爱又给力的长度标注神器！设计师、重构、前端工程师必备。马克鳗是基于AdobeAIR平台的方便高效的标注工具，可方便地为设计稿添加标记，极大节省设计师在设计稿上添加和修改标注的时间。 1、键盘功底要扎实。 敲键盘时要使用标准指法。可能你认为这是程序员的基本功，可是我发现其实很多程序员都做不到这点。看着他们敲代码时那笨拙的指法我就心急。其实炼成标准指法不难， 2、要熟悉IDE的各种快捷键及特性。 如果是C#阵营的那肯定是最新版的Vistual Studio了，如果是Java阵营的话当然是Intellij了（eclipse作为开源IDE，真心比不过Intellij）。我现在使用Intellij可以在95%的情况下不用鼠标，全键盘完成开发过程中的大部分操作。我觉得没有什么常用快捷键、不常用快捷键之分，只要你知道的快捷键就要拿来用。 3、多语言编程。 在这个世界有太多太多的编程语言，但凡稍微流行的编程语言都有自己独特的优势，而我们要善于利用每种编程语言的特点，而不是整天吵闹那种语言更强大。 总结了一些提高工作效率的关键结论： 1、决定什么是重要的事，因为在5年之内，你现在做的80%的事情都不会有任何结果。那只是无用功，没有有用的结果。 2、睡眠，饮食和运动可以让你的成果提高到三倍，因为他们可以帮助你增强你的注意力，动力和精力水平。 3、两分钟法则：如果你可以在两分钟内做完一件事（比如回复邮件或是一个家务），那就现在做。计划着一会儿完成它，记着它，并在未来完成它会花费五分钟甚至更多的时间。 4、五分钟法则：治疗拖延症最好的办法不是定目标去完成一个可怕的大任务，而是只在那件事上花五分钟。你会发现在大多数情况下，它在超出五分钟的时候依旧很顺利，因为你进入了平坦期。 5、Seinfeld生产链：如果你想做好一件事，那就每天去做。包括圣诞节，复活节和审判日。没有例外。 6、微小的生活习惯：与五分钟法则高度结合起来，你可以很快地形成好习惯。这个很有用，我测试过的。 7、你的记忆力烂透了。 即使你是一个天才也要把每件事都从你的脑子里清出来。把他们写在一个笔记本上，放进待办事项列表的应用程序里，记在手机里，或是告诉Siri，我不在意你使用的方法。 8、尽量少使用工具。我曾经测试过大多数代办事件管理器，并最终保持使用Cultured Code的Thing app和谷歌日历（iCal 是不错，但是谷歌日历和我的默认客户端Gmail结合得很好）。如果你了解了下一条规则，你用什么就并不重要了（铅笔或是钢笔都是可以的）。 9、其实每天只有4-5个小时能专心编码，充分利用这些时间。 10、编码在状态，连续几天加班是很正常的哟。11、良好的编码习惯，你的身体亦会配合你的工作，记得要持之以恒。","tags":[]},{"title":"随笔","date":"2016-03-29T08:02:01.000Z","path":"2016/03/29/随笔/","text":"坚持记录一步一脚印回头看脚印感慨时光的飞逝","tags":[{"name":"/随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"设计模式六大原则","date":"2014-01-29T02:29:02.000Z","path":"2014/01/29/设计模式六大原则/","text":"#1、开闭原则（Open Close Principle）# 开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 #2、里氏代换原则（Liskov Substitution Principle）# 里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科 #3、依赖倒转原则（Dependence Inversion Principle）# 这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。 #4、接口隔离原则（Interface Segregation Principle）# 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。 #5、迪米特法则（最少知道原则）（Demeter Principle）# 为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 #6、合成复用原则（Composite Reuse Principle）# 原则是尽量使用合成/聚合的方式，而不是使用继承。","tags":[{"name":"/设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"工厂模式","date":"2014-01-28T02:04:22.000Z","path":"2014/01/28/工厂模式/","text":"工厂模式工厂模式就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建. 举例如下：（我们举一个发送邮件和短信的例子） 首先，创建二者的共同接口： public interface Sender { public void Send(); } 创建实现类 public class MailSender implements Sender { @Override public void Send() { System.out.println(“this is mailsender!”); } } ​ public class SmsSender implements Sender { @Override public void Send() { System.out.println(“this is sms sender!”); } } 最后，建工厂类： public class SendFactory { public Sender produce(String type) { if (“mail”.equals(type)) { return new MailSender(); } else if (“sms”.equals(type)) { return new SmsSender(); } else { System.out.println(“请输入正确的类型!”); return null; } } } 测试 public class FactoryTest { public static void main(String[] args) { SendFactory factory = new SendFactory(); Sender sender = factory.produce(“sms”); sender.Send(); } } 输出：this is sms sender!","tags":[{"name":"/设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"设计模式分类","date":"2014-01-28T02:01:04.000Z","path":"2014/01/28/设计模式分类/","text":"创建型模式创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 作用:创建不同类型的对象 结构型模式结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 作用 主要针对软件的结构 行为型模式行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。","tags":[{"name":"/设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]}]